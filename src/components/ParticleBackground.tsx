import React, { useEffect, useRef } from 'react';\nimport { useGameStore } from '../stores/gameStore';\n\ninterface Particle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n  opacity: number;\n  color: string;\n}\n\nconst ParticleBackground: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const { theme, isPlaying } = useGameStore();\n  const particlesRef = useRef<Particle[]>([]);\n  const animationRef = useRef<number>();\n  \n  const getThemeColors = () => {\n    switch (theme) {\n      case 'matrix':\n        return ['#00ff00', '#00cc00', '#009900'];\n      case 'cyberpunk':\n        return ['#ff1493', '#bf00ff', '#ff6b6b'];\n      default:\n        return ['#00f5ff', '#0080ff', '#4169e1'];\n    }\n  };\n  \n  const createParticle = (canvas: HTMLCanvasElement): Particle => {\n    const colors = getThemeColors();\n    return {\n      x: Math.random() * canvas.width,\n      y: Math.random() * canvas.height,\n      vx: (Math.random() - 0.5) * 0.5,\n      vy: (Math.random() - 0.5) * 0.5,\n      size: Math.random() * 2 + 1,\n      opacity: Math.random() * 0.5 + 0.2,\n      color: colors[Math.floor(Math.random() * colors.length)]\n    };\n  };\n  \n  const initParticles = (canvas: HTMLCanvasElement) => {\n    const particleCount = isPlaying ? 150 : 100;\n    particlesRef.current = [];\n    \n    for (let i = 0; i < particleCount; i++) {\n      particlesRef.current.push(createParticle(canvas));\n    }\n  };\n  \n  const updateParticles = (canvas: HTMLCanvasElement) => {\n    particlesRef.current.forEach(particle => {\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n      \n      // Wrap around edges\n      if (particle.x < 0) particle.x = canvas.width;\n      if (particle.x > canvas.width) particle.x = 0;\n      if (particle.y < 0) particle.y = canvas.height;\n      if (particle.y > canvas.height) particle.y = 0;\n      \n      // Pulse opacity when playing\n      if (isPlaying) {\n        particle.opacity = 0.3 + Math.sin(Date.now() * 0.001 + particle.x * 0.01) * 0.2;\n      }\n    });\n  };\n  \n  const drawParticles = (ctx: CanvasRenderingContext2D) => {\n    particlesRef.current.forEach(particle => {\n      ctx.save();\n      ctx.globalAlpha = particle.opacity;\n      ctx.fillStyle = particle.color;\n      ctx.shadowBlur = 10;\n      ctx.shadowColor = particle.color;\n      \n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n      ctx.fill();\n      \n      ctx.restore();\n    });\n  };\n  \n  const drawConnections = (ctx: CanvasRenderingContext2D) => {\n    const maxDistance = 100;\n    \n    for (let i = 0; i < particlesRef.current.length; i++) {\n      for (let j = i + 1; j < particlesRef.current.length; j++) {\n        const p1 = particlesRef.current[i];\n        const p2 = particlesRef.current[j];\n        \n        const dx = p1.x - p2.x;\n        const dy = p1.y - p2.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance < maxDistance) {\n          const opacity = (1 - distance / maxDistance) * 0.2;\n          \n          ctx.save();\n          ctx.globalAlpha = opacity;\n          ctx.strokeStyle = p1.color;\n          ctx.lineWidth = 0.5;\n          ctx.shadowBlur = 5;\n          ctx.shadowColor = p1.color;\n          \n          ctx.beginPath();\n          ctx.moveTo(p1.x, p1.y);\n          ctx.lineTo(p2.x, p2.y);\n          ctx.stroke();\n          \n          ctx.restore();\n        }\n      }\n    }\n  };\n  \n  const animate = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Update and draw particles\n    updateParticles(canvas);\n    drawConnections(ctx);\n    drawParticles(ctx);\n    \n    animationRef.current = requestAnimationFrame(animate);\n  };\n  \n  const resizeCanvas = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    \n    initParticles(canvas);\n  };\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    resizeCanvas();\n    animate();\n    \n    const handleResize = () => resizeCanvas();\n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [theme, isPlaying]);\n  \n  return (\n    <canvas\n      ref={canvasRef}\n      className=\"particles fixed inset-0 pointer-events-none\"\n      style={{ zIndex: -1 }}\n    />\n  );\n};\n\nexport default ParticleBackground;